#' @title Gibbs Sampling to Identify Sequence Motifs
#'
#' @description This function identifies sequence motifs in a set of sequences using Gibbs sampling.
#'
#' @param                y (list) set of sequences to analyze; each element in ${y} is a character vector; the ith element of 
#'                         a given character vector represents the nucleotide at the ith position of that sequence
#' @param                e (numeric vector) specifies the pseudocount to avoid 0 probabilities when calculating the weight matrix
#' @param                W (numeric interger) desired motif width
#' @param                s (numeric interger vector) specifies the starting position in each sequence (select at random)
#' @param background.model (numeric float) used to calculate the relative likelihood of a given motif instance being 
#'                         generated by the motif model compared to the background model
#'
#' @return The function _outputs_ a list with three elements: 
#'                (1)  score.sample: () 
#'                (2) weight.matrix: () 
#'                (3)     s.updated: () 
#'         
#' @author Ariel W Chan, \email{ac2278@@cornell.edu}
#' 
#' @export
################################################################################
gibbs_findseqmotifs = function(y, e, W, s, background.model){
  nucleotides = c("A", "C", "G", "T")
  N = length(y)
  theta = prod(background.model)
  # Step 2: Choose a sequence at random from the set s.i[update]
  s.i = sample(1:N)
  for (update in 2:length(s.i)){
    # Step 3: Make a weight matrix model of width W from the sites
    # in all sequences except the one chosen in Step 2. 
    start = s[-s.i[update]]
    stop = s[-s.i[update]] + (W-1)
    weight.matrix = matrix(nrow=(N-1), ncol=W, dimnames=list(names(start), 1:W))
    for (i in names(start)){
      weight.matrix[i,] = y[[i]][start[i]:stop[i]]
    }
    weight.matrix = apply(weight.matrix, 2, function(x) table(factor(x, levels=nucleotides)))
    weight.matrix = (weight.matrix + e)/(N-1 + 4*e)
    
    # Step 4: Assign a probability to each position in s.i[update] using the
    # weight matrix model constructed in Step 3. 
    # Calculate the probability of a motif starting at each base in sequence s.i[update]
    score.pos = c()
    for (start.pos in 1:(length(y[[s.i[update]]])-(W-1))){
      sequence = y[[s.i[update]]][start.pos:(start.pos+(W-1))]
      score = c()
      for (j in 1:W){
        score = c(score, weight.matrix[sequence[j],j])
      }
      score.pos = c(score.pos, prod(score)/theta)
    }
    P_start.pos = score.pos/sum(score.pos)
    
    # Sample a starting position in s.i[update] based on this
    # probability distribution and set s[s.i[update]] to this new position
    s[s.i[update]] = sample(1:length(P_start.pos), 1, prob=P_start.pos)
  }
  
  # At the conclusion of each iteration (i.e., after sampling s.i for all i in [1, N]), 
  # compute the likelihood of the model by calculating the weight.matrix from the motif instances 
  # at all N starting points (the N starting points are stored in the s vector),
  # Note that this weight.matrix differs from the weight.matrix above. We 
  # are interested in computing the weight.matrix using ALL N sequences whereas 
  # before, we computed the weight.matrix as a function of N-1.  
  start = s
  stop = s + (W-1)
  weight.matrix = matrix(nrow=N, ncol=W, dimnames=list(names(start), 1:W))
  for (i in names(start)){
    weight.matrix[i,] = y[[i]][start[i]:stop[i]]
  }
  weight.matrix = apply(weight.matrix, 2, function(x) table(factor(x, levels=nucleotides)))
  weight.matrix = (weight.matrix + e)/(N + 4*e)
  
  # Calculate the likelihood ratio of all start positions assuming the given weight.matrix.
  score.sample = c()
  for (sample in 1:N){
    start = s[sample]
    stop = s[sample] + (W-1)
    sequence = structure(y[[sample]][start:stop], names=1:W)
    score.pos = c()
    for (b in 1:W){
      score.pos = c(score.pos, weight.matrix[sequence[b],b])
    }
    score.sample = c(score.sample, prod(score.pos)/theta)
  }
  return(list("score.sample"=score.sample, "weight.matrix"=weight.matrix, "s.updated"=s))
}

# Possible criteria for terminating the MCMC sampling:
#     (1) keep track of the number of iterations that have passed since the current maximum 
#         likelihood value weight.matrix was found, and terminate after some fixed 
#         number of iterations is reached
#     (2) decide ahead of time how many iterations you wish to run
#     (3) repeat the MCMC sampling until convergence of positions or motif model (i.e., 
#         weight.matrix). 

# In the example, we select 'convergence of the motif model' as the criteria for 
# terminating the MCMC sampling but do not allow the program to run for more than 
# 3000 iterations.